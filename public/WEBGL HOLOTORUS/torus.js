// Generated by CoffeeScript 1.3.3
(function() {

  window.onload = function() {
    var camera, container, gui, mouse, render, renderer, scene, shaderLines, torus;
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 500);
    camera.position.set(0, 0, -75);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    container = document.createElement('div');
    document.body.appendChild(container);
    renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.autoClear = false;
    container.appendChild(renderer.domElement);
    scene = new THREE.Scene;
    scene.fog = new THREE.Fog(0x000000, 25, 150);
    render = function() {
      torus.update();
      renderer.clear(true, true, true);
      renderer.render(scene, camera);
      return requestAnimationFrame(render);
    };
    mouse = {
      down: false,
      last: {
        x: 0,
        y: 0
      }
    };
    renderer.domElement.addEventListener('mousedown', function(event) {
      mouse.down = true;
      mouse.last.x = event.clientX;
      return mouse.last.y = event.clientY;
    });
    renderer.domElement.addEventListener('mouseup', function(event) {
      return mouse.down = false;
    });
    renderer.domElement.addEventListener('mousemove', function(event) {
      var diff;
      if (!mouse.down) {
        return;
      }
      diff = {
        x: (mouse.last.x - event.clientX) * 3 / window.innerWidth,
        y: (mouse.last.y - event.clientY) * 3 / window.innerHeight
      };
      mouse.last.x = event.clientX;
      mouse.last.y = event.clientY;
      torus.particles.rotation.z += diff.x;
      return torus.particles.rotation.x += diff.y;
    });
    torus = {
      rotationSpeedX: 0.01,
      rotationSpeedY: 0.01,
      rotationSpeedZ: 0.01,
      involutionSpeed: 0.01,
      involution: 0,
      size: 4,
      r1: 20,
      r2: 10,
      border: /border=1/.test(window.location.search),
      qty: {
        chips: 12,
        segments: 36
      },
      init: function() {
        var u, v, vert, _i, _j, _ref, _ref1;
        this.geometry = new THREE.Geometry;
        for (u = _i = 0, _ref = this.qty.segments; 0 <= _ref ? _i < _ref : _i > _ref; u = 0 <= _ref ? ++_i : --_i) {
          for (v = _j = 0, _ref1 = this.qty.chips; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; v = 0 <= _ref1 ? ++_j : --_j) {
            vert = new THREE.Vector3;
            vert.u = u / this.qty.segments;
            vert.v = v / this.qty.chips;
            this.geometry.vertices.push(vert);
            this.geometry.colors.push(new THREE.Color().setHSV(vert.v, 1, 1));
          }
        }
        this.particles = new THREE.ParticleSystem(this.geometry, new THREE.ParticleBasicMaterial({
          vertexColors: THREE.VertexColors,
          transparent: true
        }));
        this.particles.sortParticles = true;
        return scene.add(this.particles);
      },
      restart: function() {
        var oldRotation;
        oldRotation = this.particles.rotation;
        scene.remove(this.particles);
        this.init();
        return this.particles.rotation = oldRotation;
      },
      update: function() {
        var vert, _i, _len, _ref;
        this.particles.material.size = this.size;
        this.particles.rotation.x += this.rotationSpeedX / 60;
        this.particles.rotation.y += this.rotationSpeedY / 60;
        this.particles.rotation.z += this.rotationSpeedZ / 60;
        this.involution += this.involutionSpeed / 60;
        _ref = this.geometry.vertices;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          vert = _ref[_i];
          vert.copy(this.placeVert({
            u: vert.u,
            v: vert.v,
            r1: this.r1,
            r2: this.r2,
            involution: this.involution
          }));
        }
        return this.geometry.verticesNeedUpdate = true;
      },
      stopAnimation: function() {
        this.rotationSpeedX = 0;
        this.rotationSpeedY = 0;
        this.rotationSpeedZ = 0;
        return this.involutionSpeed = 0;
      },
      placeVert: function(options) {
        var r1, r2, u, v;
        if (options == null) {
          options = {};
        }
        r1 = options.r1;
        r2 = options.r2;
        u = options.u * 2 * Math.PI;
        v = options.v * 2 * Math.PI;
        v += u;
        u += options.involution * 2 * Math.PI;
        return new THREE.Vector3((r1 + r2 * Math.cos(u)) * Math.cos(v), (r1 + r2 * Math.cos(u)) * Math.sin(v), r2 * Math.sin(u) * 1.6180339887);
      }
    };
    shaderLines = THREE.ShaderLib.particle_basic.fragmentShader.split("\n");
    shaderLines[shaderLines.length - 1] = "  // custom shader\n  \n  vec4 circle = vec4(\n    vec3(\n      " + (/border=1/.test(window.location.search) ? "smoothstep(0.4, 0.37, length(gl_PointCoord - vec2(0.5)))" : "1.0") + "\n    ),\n    smoothstep(0.5, 0.47, length(gl_PointCoord - vec2(0.5)))\n  );\n  \n  gl_FragColor *= circle;\n\n  // end custom shader\n}";
    THREE.ShaderLib.particle_basic.fragmentShader = shaderLines.join("\n");
    torus.init();
    render();
    gui = new dat.GUI;
    gui.add(torus, 'r1', 0, 50).step(0.01);
    gui.add(torus, 'r2', 0, 50).step(0.01);
    gui.add(torus, 'size', 1, 10).step(0.01);
    gui.add(torus.qty, 'chips', 1, 250).step(1).onChange(function() {
      return torus.restart();
    });
    gui.add(torus.qty, 'segments', 3, 250).step(1).onChange(function() {
      return torus.restart();
    });
    gui.add(torus, 'border').onChange(function(val) {
      return window.location.href = "?border=" + (val ? 1 : 0);
    });
    gui.add(torus, 'involutionSpeed', -.5, .5).listen();
    gui.add(torus, 'rotationSpeedX').min(-1.5).max(1.5).listen();
    gui.add(torus, 'rotationSpeedY').min(-1.5).max(1.5).listen();
    gui.add(torus, 'rotationSpeedZ').min(-1.5).max(1.5).listen();
    gui.add(torus, 'stopAnimation');
    torus.rotationSpeedX = 0;
    torus.rotationSpeedY = 0;
    torus.rotationSpeedZ = 0;
    return torus.involutionSpeed = 0;
  };

}).call(this);
